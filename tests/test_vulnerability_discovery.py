import pytest
import asyncio
import time
import sys
import os

# Add backend directory to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'backend')))

from unittest.mock import MagicMock, patch, AsyncMock
import httpx
from scanner.target_analyzer import TargetAnalyzer, DiscoveredEndpoint
from agents.sql_injection_agent import SQLInjectionAgent
from agents.xss_agent import XSSAgent
from models.vulnerability import VulnerabilityType, Severity

@pytest.mark.asyncio
async def test_spa_form_discovery():
    # Mock HTML with a "modern" login area (no form tag, no onclick)
    html = """
    <html>
        <body>
            <div id="login-container">
                <input id="user-id" type="text" placeholder="Username">
                <input id="pass-id" type="password" placeholder="Password">
                <button class="btn-login">Sign In</button>
            </div>
        </body>
    </html>
    """
    
    # Mock response
    mock_resp = MagicMock(spec=httpx.Response)
    mock_resp.status_code = 200
    mock_resp.text = html
    mock_resp.headers = httpx.Headers({"Content-Type": "text/html"})
    mock_resp.cookies = MagicMock()
    mock_resp.cookies.jar = []
    
    analyzer = TargetAnalyzer()
    with patch.object(analyzer, '_fetch_with_error_handling', AsyncMock(return_value=mock_resp)):
        analysis = await analyzer.analyze("http://example.com")
        
    # Check if SPA form was discovered
    spa_forms = [f for f in analysis.forms if f.get("form_type") == "spa"]
    assert len(spa_forms) > 0
    assert any(i["name"] == "user-id" for i in spa_forms[0]["inputs"])
    assert spa_forms[0]["has_password"] is True

@pytest.mark.asyncio
async def test_blind_sqli_login_bypass():
    # Mock behavior for time-based blind SQLi
    agent = SQLInjectionAgent()
    
    async def side_effect(url, method="GET", **kwargs):
        mock_resp = MagicMock()
        mock_resp.status_code = 500
        mock_resp.text = "Internal Server Error"
        # If payload contains SLEEP, make it slow
        if "SLEEP" in str(kwargs.get("json", "")):
            mock_resp.elapsed.total_seconds.return_value = 5.0
        else:
            mock_resp.elapsed.total_seconds.return_value = 0.1
        return mock_resp

    with patch.object(agent, 'make_request', side_effect):
        results = await agent._test_login_endpoints("http://example.com", None, "Generic")
        
    assert len(results) > 0
    assert results[0].vulnerability_type == VulnerabilityType.SQL_INJECTION
    assert "Time-based" in results[0].detection_method

@pytest.mark.asyncio
async def test_xss_parameter_guessing():
    # Test that XSS agent guesses parameters for /search
    agent = XSSAgent()
    
    endpoints = [{"url": "http://example.com/search", "method": "GET", "params": {}}]
    
    # Mock make_request to record calls
    mock_make_request = AsyncMock()
    mock_make_request.return_value = MagicMock(status_code=200, text="test")
    
    agent.make_request = mock_make_request
    await agent.scan("http://example.com", endpoints)
    
    # Check if it tried common params like 'q'
    call_args_list = mock_make_request.call_args_list
    params_tested = []
    for call in call_args_list:
        p = call.kwargs.get("params")
        if p:
            params_tested.extend(p.keys())
            
    assert "q" in params_tested or "query" in params_tested
